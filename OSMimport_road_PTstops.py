# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OSMimport
                                 A QGIS plugin
 It imports easily the road map of the city and the stops for each public transport
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-12
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Luigi Dal Bosco
        email                : luigi.dalbosco@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QListWidgetItem
from qgis.core import  (QgsCoordinateReferenceSystem, 
                        QgsVectorLayer, 
                        QgsVectorFileWriter, 
                        QgsRasterLayer, 
                        QgsProject,
 )

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .OSMimport_road_PTstops_dialog import OSMimportDialog
import os.path

# Import for the code in def run()
import pandas as pd
from qgis import processing
from .core_functions import (busroutes, 
                            full_city_roads, 
                            Selected_Ttbls, 
                            preapare_GTFSstops_by_transport, 
                            time_tables_perTransport, angles, 
                            rectangles_sidewalk, 
                            rectangles_OSMonROADline,
                            OSMintersecGTFS, 
                            OSM_PTstps_dwnld, 
                            stp_posGTFSnm_rect, 
                            joinNEWandValidOSM, 
                            display_vector_layer, zoom_to_layer, 
                            highway_average_speed, 
                            transcript_main_files,
                            Ttbls_plus,
                            angle_onRD_sidewalk,
                            shape_assignement,
                            if_not_make
)

class OSMimport:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        self.OSMimport_dialog = OSMimportDialog()

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OSMimport_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&OSM import roads and transport stops')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OSMimport', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/OSMimport_road_PTstops/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'1. Import OSM city\'s roads and PT stops'),
            callback=self.run,
            parent=self.iface.mainWindow())
        
        self.OSMimport_dialog.UpdatebusButton.clicked.connect(self.__updateBuses)

        # will be set False in run()
        self.first_start = True

    def __updateBuses(self):        
        self.OSMimport_dialog.listbusWidget.clear()  # Clear existing items
        dwnldfld = self.OSMimport_dialog.DownloadQgsFolderWidget.filePath()
        routes = pd.read_csv(str(dwnldfld)+'/routes.txt')
        ls_transport = routes.route_short_name.unique()
        for trnsprt in ls_transport:
            self.OSMimport_dialog.listbusWidget.addItem(QListWidgetItem(str(trnsprt)))

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&OSM import roads and transport stops'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            

        # show the dialog
        self.OSMimport_dialog.show()
        # Run the dialog event loop
        result = self.OSMimport_dialog.exec_()

        # load selected Busses
        selected_items = self.OSMimport_dialog.listbusWidget.selectedItems()
        
        # load the downloads and output folders
        dwnldfld = self.OSMimport_dialog.DownloadQgsFolderWidget.filePath()

        outputspath = self.OSMimport_dialog.OutPutQgsFolderWidget.filePath()
        # See if OK was pressed
        if result:

            temp_folder = 'OSM_data'
            road_temp_folder = os.path.join(dwnldfld,temp_folder)
            
            trips_txt = str(dwnldfld)+'/trips.txt'

            stops_txt = str(dwnldfld)+'/stops.txt'
            stops = pd.read_csv(stops_txt)

            south = round(float(stops.stop_lat.min()) -0.05,6)
            west = round(float(stops.stop_lon.min()) -0.05,6)
            north = round(float(stops.stop_lat.max()) +0.05,6)
            east = round(float(stops.stop_lon.max()) +0.05,6)

            OSM_ways_name = 'OSM_ways'
            OSM_ways_gpkg = str(road_temp_folder)+'/'+str(OSM_ways_name)+'.gpkg'
            
            extent = str(south)+','+str(west)+','+str(north)+','+str(east)
            extent_quickosm = str(south)+','+str(west)+','+str(north)+','+str(east)+' [EPSG:4326]'
            params = {'QUERY':'[out:xml] [timeout:25];\n(    \n    way["highway"="service"]('+str(extent)+');\n    way["highway"="living_street"]('+str(extent)+');\n    way["highway"="motorway"]('+str(extent)+');\n    way["highway"="primary"]('+str(extent)+');\n    way["highway"="secondary"]('+str(extent)+');\n    way["highway"="tertiary"]('+str(extent)+');\n    way["highway"="residential"]('+str(extent)+');\n    way["highway"="unclassified"]('+str(extent)+');\n    way["highway"="motorway_link"]('+str(extent)+');\n    way["highway"="primary_link"]('+str(extent)+');\n    way["highway"="secondary_link"]('+str(extent)+');\n    way["highway"="tertiary_link"]('+str(extent)+');\n    way["highway"="residential"]('+str(extent)+');\n    way["highway"="motorway_junction"]('+str(extent)+');\n    \n  \t\n);\n(._;>;);\nout body;',
                    'TIMEOUT':180,
                    'SERVER':'https://overpass-api.de/api/interpreter',
                    'EXTENT':extent_quickosm,
                    'AREA':'',
                    'FILE': OSM_ways_gpkg}
            
            
            # naming files and paths

            OSM_roads_name = 'OSM_roads'
            OSM_roads_gpkg = str(road_temp_folder)+'/'+str(OSM_roads_name)+'.gpkg'
            
            OSM_roads_nameCSV = 'OSM_roads_CSV'
            OSM_roads_csv = str(road_temp_folder)+'/'+str(OSM_roads_name)+'.csv'

            highway_speed_name = 'highway_average_speed'
            highway_speed_csv = str(road_temp_folder)+'/'+str(highway_speed_name)+'.csv'

            bus_lanes_name = 'OSM_bus_lanes'
            OSM_bus_lanes_gpkg = str(road_temp_folder)+'/'+str(bus_lanes_name)+'.gpkg'

            full_roads_name = 'full_city_roads'
            full_roads_gpgk = str(road_temp_folder)+'/'+str(full_roads_name)+'.gpkg'

            city_roads_name = 'city roads'

            Ttlbs_txt = str(dwnldfld)+'/stop_times.txt'

            Ttbls_plus_name = 'stop_times_plus'
            Ttbls_plus_csv = str(dwnldfld)+'/'+str(Ttbls_plus_name)+'.csv'

            Ttbls_selected_name = 'stop_times_selected_lines'
            Ttbls_selected_txt = str(dwnldfld)+'/'+str(Ttbls_selected_name)+'.txt'

            temp_folder = str(os.getenv("USERNAME"))+'_main_files'
            main_files_fld = os.path.join(str(dwnldfld)+'/'+str(temp_folder))
            main_files_csv = str(dwnldfld)+'/'+str(temp_folder)+'/main_files.csv'
            
            temp_folder = 'temp/trip_id_assignement'
            folder_trip_id_assign = os.path.join(dwnldfld,temp_folder)

            ls_buses_done_name = 'buses'
            ls_buses_done_csv = str(main_files_fld)+'/'+str(ls_buses_done_name)+'.csv'

            tempfolder = 'temp/stop_times_perroute'
            temp_folder_Ttbls = os.path.join (dwnldfld,tempfolder)
            
            tempfolder = 'temp/GTFSstops&segments_perroute'
            temp_folder_GTFSstops = os.path.join (dwnldfld,tempfolder)

            tempfolder = 'temp/temp_roads_angls'
            temproadfldr = os.path.join(dwnldfld,tempfolder)

            tempfolderGTFSnm = 'temp/temp_GTFSnomatch'
            temp_GTFSnm_folder = os.path.join (dwnldfld,tempfolderGTFSnm)
            
            tempfolder = 'temp/temp_rect'
            temp_rect_folder = os.path.join (dwnldfld,tempfolder)

            tempfolder = 'perdinst'
            perdist = os.path.join(temp_rect_folder,tempfolder)

            temp_folder = 'temp/OSM_PTstops'
            OSMstops_temp_folder = os.path.join(dwnldfld,temp_folder)
             
            tempfolder = 'temp/temp_OSM'
            temp_OSM_folder = os.path.join (dwnldfld,tempfolder)
            
            tempfolder = 'temp/temp_GTFSpos'
            temp_GTFSpos_folder = os.path.join (dwnldfld,tempfolder)

            tempfolder = 'temp/temp_OSM_forrouting'
            temp_OSM_for_routing = os.path.join (dwnldfld,tempfolder)
                        
            GTFSnm_angledf_csv = str(outputspath+'/GTFSnm_angl.csv')
            OSMwithGTFS_csv = str(outputspath)+'/OSMintersecGTFS.csv'
            dfnomatch_csv = str(outputspath)+'/OSMnomatch.csv'
            GTFSnm_rect_csv = str(outputspath)+'/GTFSnm_rect.csv'
            GTFSnmRCT_posdf_csv = str(outputspath)+'/GTFSnmRCT_NEWpos.csv'
            OSM4rout_file = str(outputspath)+'/OSM4routing.csv'

            GTFSnm_angledf = pd.DataFrame()
            OSMwithGTFS = pd.DataFrame()
            dfnomatch = pd.DataFrame()
            GTFSnm_rect = pd.DataFrame()
            GTFSnmRCT_posdf = pd.DataFrame()
            OSM4routing = pd.DataFrame()

            # condition if the plugin have aleady run at list ones
            if not os.path.exists(main_files_csv):
                transcript_main_files(main_files_fld,main_files_csv,OSM_ways_name,OSM_ways_gpkg,OSM_roads_name,OSM_roads_gpkg,OSM_roads_nameCSV,OSM_roads_csv,highway_speed_name,highway_speed_csv, bus_lanes_name, OSM_bus_lanes_gpkg,full_roads_name, full_roads_gpgk,Ttbls_selected_name, Ttbls_selected_txt)
                
                os.makedirs(road_temp_folder)

                processing.run("quickosm:downloadosmdatarawquery", params)
                
                Roads_layer_file = str(OSM_ways_gpkg)+'|layername=OSM_ways_lines'
                Roads_layer =  QgsVectorLayer(Roads_layer_file,"Roads","ogr")
                QgsVectorFileWriter.writeAsVectorFormat(Roads_layer, OSM_roads_gpkg, "UTF-8", Roads_layer.crs(), "GPKG")
                QgsVectorFileWriter.writeAsVectorFormat(Roads_layer,OSM_roads_csv,"utf-8",driverName = "CSV")
    
                highway_average_speed(OSM_roads_csv,highway_speed_csv)
            
                busroutes(bus_lanes_name, OSM_bus_lanes_gpkg,OSM_roads_gpkg,highway_speed_csv)

                full_city_roads(OSM_roads_gpkg,OSM_bus_lanes_gpkg, full_roads_gpgk,city_roads_name,highway_speed_csv)

            if_not_make(temp_folder_Ttbls)
            if_not_make(temp_folder_GTFSstops)
            if_not_make(temproadfldr)
            if_not_make(temp_GTFSnm_folder)
            if_not_make(temp_rect_folder)
            if_not_make(perdist)
            if_not_make(OSMstops_temp_folder)
            if_not_make(temp_OSM_folder)
            if_not_make(temp_GTFSpos_folder)
            if_not_make(temp_OSM_for_routing)
            if_not_make(folder_trip_id_assign)


            if os.path.exists(GTFSnm_angledf_csv):
                GTFSnm_angledf = pd.read_csv(GTFSnm_angledf_csv)
            if os.path.exists(OSMwithGTFS_csv):
                OSMwithGTFS = pd.read_csv(OSMwithGTFS_csv)
            if os.path.exists(dfnomatch_csv):
                dfnomatch = pd.read_csv(dfnomatch_csv)
            if os.path.exists(GTFSnm_rect_csv):
                GTFSnm_rect = pd.read_csv(GTFSnm_rect_csv)
            if os.path.exists(GTFSnmRCT_posdf_csv):
                GTFSnmRCT_posdf = pd.read_csv(GTFSnmRCT_posdf_csv)
            if os.path.exists(OSM4rout_file):
                OSM4routing = pd.read_csv(OSM4rout_file)

            if os.path.exists(ls_buses_done_csv):
                ls_buses_df = pd.read_csv(ls_buses_done_csv)
                prev_ls_buses = [str(bus) for bus in list(ls_buses_df.route_short_name)]
                del ls_buses_df

            try:
                prev_ls_buses
            except NameError:
                prev_ls_buses = []

            ls_buses_selected = [item.text() for item in selected_items]
            print('the buses you have choosen are: '+str(ls_buses_selected))

            ls_buses = [bus for bus in ls_buses_selected if bus not in prev_ls_buses]
            
            prev_ls_buses = prev_ls_buses + ls_buses            
            ls_buses_df = pd.DataFrame(prev_ls_buses).rename(columns={0:'route_short_name'})
            if os.path.exists(ls_buses_done_csv):
                os.remove(ls_buses_done_csv)
            ls_buses_df.to_csv(ls_buses_done_csv, index=False)

            if not os.path.exists(Ttbls_plus_csv):
                Ttbls_plus(Ttlbs_txt,Ttbls_plus_csv,dwnldfld,trips_txt)

            Selected_Ttbls(ls_buses,Ttbls_selected_txt,Ttbls_plus_csv) 

            print('the main Time Tables is ready, I start to create the dataframes for each single transport')
           
            stops_times_plus = pd.read_csv(Ttbls_selected_txt)

            # create transport Times tables for each transport

            lsrts = stops_times_plus.route_id.unique()

            lslines=[]

            lines_df_csv = str(dwnldfld)+'/lines_files_list.csv'

            if os.path.exists(lines_df_csv):
                lines_df = pd.read_csv(lines_df_csv,dtype={'route_short_name':str})
            else:
                lines_df = pd.DataFrame()
            
            lines_df_row_init = len(lines_df)
            trnsprt_type = 'trnsprt'

            sumTtbls = 0 
            i_row = lines_df_row_init
            for rt in lsrts:
                line, nameline, Ttbl_file, rt_srt_nm = time_tables_perTransport(rt,stops_times_plus,temp_folder_Ttbls,lslines, trnsprt_type)
                sumTtbls = sumTtbls + len(line)
                lines_df.loc[i_row,'line_name'] = nameline
                lines_df.loc[i_row,'route_short_name'] = rt_srt_nm
                lines_df.loc[i_row,'GTFSstop_times'] = Ttbl_file
                lslines.append(nameline)
                i_row += 1
                
            print ('The Time tables are ready')

            if len(stops_times_plus) == sumTtbls:
                print ('all the lines are there')
            else:
                dif = len(stops_times_plus)-sumTtbls
                print (str(dif)+' scores are missing')
            
            print('prepariing the GTFSstops geopackages')
            
            # creating the a df for listing the files paths 
                        
            i_row = lines_df_row_init
            while i_row < len(lines_df):
                Ttbl_file = lines_df.loc[i_row,'GTFSstop_times'] 
                line = lines_df.loc[i_row,'line_name']
                shrt_name = lines_df.loc[i_row,'route_short_name']
                GTFSstops, Ttbl_with_sequences_csv = preapare_GTFSstops_by_transport(stops_txt,Ttbl_file,line,temp_folder_GTFSstops,shrt_name,temp_folder_Ttbls)
                lines_df.loc[i_row,'GTFSstops&segments'] = GTFSstops
                lines_df.loc[i_row,'GTFSstop_times_with_seq'] = Ttbl_with_sequences_csv
                i_row=i_row+1 
            del i_row
            
            i_row = lines_df_row_init
            while i_row < len(lines_df):
                line = lines_df.loc[i_row,'line_name']
                Ttbl_file = lines_df.loc[i_row,'GTFSstop_times']
                GTFSstops_csv = lines_df.loc[i_row,'GTFSstops&segments']
                line_trip_csv = str(folder_trip_id_assign)+'/'+str(line)+'_trip_assignement.csv'
                shape_assignement(GTFSstops_csv,Ttbl_file,line_trip_csv,trips_txt)
                lines_df.loc[i_row,'trip_assignement'] = line_trip_csv
                i_row += 1

            city_roads_layer = QgsVectorLayer(OSM_roads_gpkg,city_roads_name,"ogr")

            print ('... adding the angles to the GTFSstops')

            # create GTFSstops gpkg with angle of the nearest road 

            i_row = lines_df_row_init
            while i_row < len(lines_df):
                line = lines_df.loc[i_row,'line_name']
                GTFSstops_path = lines_df.loc[i_row,'GTFSstops&segments']
                GTFSstops_angle, GTFSnm_RD, GTFSnm_angCSV, spl_file = angles(city_roads_layer,line,GTFSstops_path,temproadfldr,temp_GTFSnm_folder)
                lines_df.loc[i_row,'GTFSnm_RD'] = GTFSnm_RD
                lines_df.loc[i_row,'GTFSstps_angle'] = GTFSstops_angle
                lines_df.loc[i_row,'GTFSnm_angCSV'] = GTFSnm_angCSV
                lines_df.loc[i_row, 'Spl_roads'] = spl_file
                GTFSnm_angl_toconcat = pd.read_csv(GTFSnm_angCSV)
                GTFSnm_angledf = pd.concat([GTFSnm_angledf,GTFSnm_angl_toconcat],ignore_index=True) 
                i_row = i_row+1

            if os.path.exists(GTFSnm_angledf_csv):
                os.remove(GTFSnm_angledf_csv)
            GTFSnm_angledf.to_csv(GTFSnm_angledf_csv, index=False)

            i_row = lines_df_row_init
            while i_row < len(lines_df):
                line = lines_df.loc[i_row,'line_name']
                GTFSstops_angle =lines_df.loc[i_row,'GTFSstps_angle']
                GTFSstops_angle_sidewalk_gpkg = str(temproadfldr)+'/GTFS'+str(line)+'_anlge_sidewalk.gpkg'
                GTFSstops_angle_OSMonROADline_gpkg = str(temproadfldr)+'/GTFS'+str(line)+'_OSMonROADline.gpkg'
                lines_df.loc[i_row,'GTFSstps_angle_sidewalk'] = GTFSstops_angle_sidewalk_gpkg
                lines_df.loc[i_row,'GTFSstps_angle_OSMonROADline'] = GTFSstops_angle_OSMonROADline_gpkg
                angle_onRD_sidewalk(GTFSstops_angle, GTFSstops_angle_sidewalk_gpkg,GTFSstops_angle_OSMonROADline_gpkg)
                i_row = i_row+1


            print('Creating vector layers to join to the OSM stops')

            trnsprt_long = 0.00020
            road_average_width = 0.00008
            
            i_row = lines_df_row_init
            while i_row < len(lines_df):

                GTFSstops_angle_sidewalk_gpkg = lines_df.loc[i_row,'GTFSstps_angle_sidewalk']
                line = lines_df.loc[i_row,'line_name']
                GTFSstps_rect_sidewalk_csv = str(temp_rect_folder)+'/GTFSangl_sidewalk_'+str(line)+'.csv'
                GTFSstps_rect_sidewalk_gpkg = str(temp_rect_folder)+'/rects_sidewalk_'+str(line)+'.gpkg'
                rectangles_sidewalk(GTFSstops_angle_sidewalk_gpkg, trnsprt_long,line, GTFSstps_rect_sidewalk_gpkg, GTFSstps_rect_sidewalk_csv)
                lines_df.loc[i_row,'GTFSstps_rect_sidewalk_gpkg'] = GTFSstps_rect_sidewalk_gpkg
                lines_df.loc[i_row,'GTFSstps_rect_sidewalk_csv'] = GTFSstps_rect_sidewalk_csv
                
                GTFSstops_path_OSMonROADline = lines_df.loc[i_row,'GTFSstps_angle_OSMonROADline']
                GTFSstps_rect_OSMonROADline_gpkg = str(temp_rect_folder)+'/rects_OSMonROADline_'+str(line)+'.gpkg'
                rectangles_OSMonROADline(GTFSstops_path_OSMonROADline,trnsprt_long, road_average_width,line,GTFSstps_rect_OSMonROADline_gpkg)
                GTFSstps_rect_gpkg = str(temp_rect_folder)+'/rects_'+str(line)+'.gpkg'
                lines_df.loc[i_row,'GTFSstps_rect'] = GTFSstps_rect_gpkg
                ls_GTFSstps_rect = [GTFSstps_rect_sidewalk_gpkg,GTFSstps_rect_OSMonROADline_gpkg]
                params = {'LAYERS':ls_GTFSstps_rect,
                        'CRS':QgsCoordinateReferenceSystem('EPSG:4326'),
                        'OUTPUT':GTFSstps_rect_gpkg}
                processing.run("native:mergevectorlayers",params)

                i_row = i_row + 1

            i_row = lines_df_row_init

            while i_row < len(lines_df):
                line = lines_df.loc[i_row,'line_name']
                shrt_name = lines_df.loc[i_row,'route_short_name']

                OSM_PTstp_rel_name = 'PT_stops_rel_'+str(shrt_name)
                OSM_PTstp_rel_gpkg = str(OSMstops_temp_folder)+'/'+str(OSM_PTstp_rel_name)+'.gpkg'
                OSM_PTstp_name = 'PT_stop_position_'+str(shrt_name)
                OSM_PTstp_gpkg = str(OSMstops_temp_folder)+'/'+str(OSM_PTstp_name)+'.gpkg'
                lines_df.loc[i_row,'OSM_PTstp'] = OSM_PTstp_gpkg
                OSM_PTstps_dwnld(extent, extent_quickosm,OSM_PTstp_rel_gpkg,OSM_PTstp_gpkg,shrt_name, OSM_PTstp_rel_name, OSM_PTstp_name)
                i_row += 1

            print('joining OSM and GTFS')
            
            i_row = lines_df_row_init
            while i_row < len(lines_df):
                rect = lines_df.loc[i_row,'GTFSstps_rect']
                srtnm = lines_df.loc[i_row,'route_short_name']
                OSM_PTstp_gpkg = lines_df.loc[i_row,'OSM_PTstp']
                intersect, match, OSMjnGTFS, OSMnomatch = OSMintersecGTFS(rect,OSM_PTstp_gpkg,temp_OSM_folder,srtnm)
                lines_df.loc[i_row,'OSMintersecGTFS'] = OSMjnGTFS
                lines_df.loc[i_row,'OSMnomatch'] = OSMnomatch

                OSMwithGTFS = pd.concat ([OSMwithGTFS,intersect],ignore_index=True)
                dfnomatch = pd.concat ([dfnomatch,match],ignore_index=True)
                
                i_row = i_row + 1

            if os.path.exists(OSMwithGTFS_csv):
                os.remove(OSMwithGTFS_csv)
            OSMwithGTFS.to_csv(OSMwithGTFS_csv, index=False)
            if os.path.exists(dfnomatch_csv):
                os.remove(dfnomatch_csv)
            dfnomatch.to_csv(dfnomatch_csv, index=False)
            
            # create list of GTFS rectangls that don't match with any OSM
            i_row = lines_df_row_init
            while i_row < len(lines_df):
                GTFSnmRCT_csv = str(temp_GTFSnm_folder)+'/GTFSnmRCT_'+str(lines_df.loc[i_row,'line_name'])+'.csv'
                OSMjnGTFS = pd.read_csv(lines_df.loc[i_row,'OSMintersecGTFS'])
                lsGTFSjoined = OSMjnGTFS.GTFS_stop_id.unique()
                GTFSstops = pd.read_csv(lines_df.loc[i_row,'GTFSstops&segments'])
                GTFSnom = GTFSstops[~GTFSstops.stop_id.isin(lsGTFSjoined)]
                GTFSnm_RD = pd.read_csv(lines_df.loc[i_row,'GTFSnm_angCSV'])
                lsGTFSnmRD = GTFSnm_RD.stop_id.unique()
                GTFSnmRCT = GTFSnom[~GTFSnom.stop_id.isin(lsGTFSnmRD)]
                GTFSnmRCT.to_csv(GTFSnmRCT_csv, index = False)
                lines_df.loc[i_row,'GTFSnmRCT'] = GTFSnmRCT_csv
                GTFSnm_rect = pd.concat ([GTFSnm_rect,GTFSnmRCT],ignore_index=True)
                
                i_row += 1
            
            if os.path.exists(GTFSnm_rect_csv):
                os.remove(GTFSnm_rect_csv)
            GTFSnm_rect.to_csv(GTFSnm_rect_csv, index=False)

            i_row = lines_df_row_init
            while i_row<len(lines_df):
                line = lines_df.loc[i_row,'line_name']
                GTFSnmRCT = lines_df.loc[i_row,'GTFSnmRCT']
                splt_roads = lines_df.loc[i_row,'Spl_roads']
                NEWpos_file_nmRCT = stp_posGTFSnm_rect(GTFSnmRCT,line,splt_roads,temp_GTFSpos_folder,trnsprt_long)
                lines_df.loc[i_row, 'GTFSnmRCT_newOSMpos'] = NEWpos_file_nmRCT
                posdf = pd.read_csv(NEWpos_file_nmRCT)
                GTFSnmRCT_posdf = pd.concat([GTFSnmRCT_posdf,posdf],ignore_index=True)
                i_row += 1
            
            if os.path.exists(GTFSnmRCT_posdf_csv):
                os.remove(GTFSnmRCT_posdf_csv)
            GTFSnmRCT_posdf.to_csv(GTFSnmRCT_posdf_csv, index=False)
              
            i_row = lines_df_row_init
            while i_row < len(lines_df):
                newOSMpos = lines_df.loc[i_row, 'GTFSnmRCT_newOSMpos'] 
                GTFSnomatch_RD = lines_df.loc[i_row,'GTFSnm_angCSV']
                OSMintersectGTFS = lines_df.loc[i_row,'OSMintersecGTFS']
                GTFSstps_seg = lines_df.loc[i_row,'GTFSstops&segments'] 
                line = lines_df.loc[i_row,'line_name']
                OSMstops_forrouting = joinNEWandValidOSM(newOSMpos,GTFSnomatch_RD,OSMintersectGTFS,GTFSstps_seg,temp_OSM_for_routing,line,stops_txt)
                lines_df.loc[i_row,'OSM4routing'] = OSMstops_forrouting
                OSM4r_toconcat = pd.read_csv(OSMstops_forrouting)
                OSM4routing = pd.concat([OSM4routing,OSM4r_toconcat],ignore_index=True)
                i_row += 1
            
            if os.path.exists(OSM4rout_file):
                os.remove(OSM4rout_file)         
            OSM4routing.to_csv(OSM4rout_file,index=False)

            # publishing the back ground for better read of the data
            if not QgsProject.instance().mapLayersByName('SWISSIMAGE 10 cm'):
                uri = "contextualWMSLegend=0&crs=EPSG:4326&dpiMode=7&featureCount=10&format=image/jpeg&layers=ch.swisstopo.swissimage&styles=default&tilePixelRatio=0&url=https://wms.geo.admin.ch/"
                CHimage_layer = QgsRasterLayer(uri, "SWISSIMAGE 10 cm", 'wms')
                QgsProject.instance().addMapLayer(CHimage_layer)

            if not QgsProject.instance().mapLayersByName('OSM Standard'):
                uri = "type=xyz&zmin=0&zmax=19&url=http://tile.openstreetmap.org/{z}/{x}/{y}.png"
                OSMmap_layer = QgsRasterLayer(uri, "OSM Standard", 'wms')
                QgsProject.instance().addMapLayer(OSMmap_layer)

            if not QgsProject.instance().mapLayersByName(city_roads_name):
                city_roads_layer = QgsVectorLayer(OSM_roads_gpkg,city_roads_name,"ogr")
                QgsProject.instance().addMapLayer(city_roads_layer)

            # publishing the trips on the canvas
            ls_buses_todisp = [str(bus) for bus in ls_buses_selected]
            ls_buses_select_df = pd.DataFrame(ls_buses_todisp).rename(columns={0:'route_short_name'})
            ls_buses_select_df = ls_buses_select_df.astype({'route_short_name':'str'})
            ls_buses_select_df = ls_buses_select_df.merge(lines_df, how='left', on='route_short_name')
            ls_trnsprt_todisplay = list(ls_buses_select_df.line_name.unique())
            ls_files = os.listdir(temp_OSM_for_routing)
            ls_gpkg = [file for file in ls_files if ".gpkg" in file]

            for trnsprt in ls_trnsprt_todisplay:
                to_display = [gpkg for gpkg in ls_gpkg if trnsprt in gpkg]
                for layer in to_display:
                    if not QgsProject.instance().mapLayersByName(str(layer[:-5])):
                        OSM_trip4rout_gpkg = str(temp_OSM_for_routing)+'/'+str(layer)
                        OSM_trip4rout_layer = QgsVectorLayer(OSM_trip4rout_gpkg,str(layer[:-5]),"ogr")
                        QgsProject.instance().addMapLayer(OSM_trip4rout_layer)

            # saving the lines df
            if os.path.exists(lines_df_csv):
                os.remove(lines_df_csv)   
            lines_df.to_csv(lines_df_csv,index=False)
            
            print('Done! : your files are ready')

            